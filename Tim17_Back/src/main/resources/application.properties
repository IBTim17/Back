# app port
server.port=8080
#server.port=8443

spring.datasource.url=jdbc:postgresql://localhost:5432/mydatabase
spring.datasource.username=postgres
spring.datasource.password=password

# Show SQL statements
spring.jpa.show-sql=true
# Actions to perform on DB = should the tables be created on application startup
spring.jpa.hibernate.ddl-auto= create-drop


#Spring DataSource drajver koji ?e se koristiti za komunikaciju aplikacije sa bazom
spring.datasource.driverClassName=org.postgresql.Driver

#Navodi se URL do baze koja je pokrenuta u lokalu na podrazumevanom portu 5432 i na serveru je kreirana ?ema baze pod nazivom "jpa"
#https://www.pgadmin.org/docs/pgadmin4/4.14/schema_dialog.html (ako koristimo Hibernate za kreiranje tabela, SQL deo sa linka nije potreban)
#spring.datasource.url=jdbc:h2:mem:testdb

#Navode se kredencijali za konekciju na server baze
#spring.datasource.username=sa
#spring.datasource.password=

#Umesto da sami pi?emo SQL skriptu za kreiranje tabela u bazi, Hibernate kreira tabele na osnovu anotacija @Entity i kada aplikacija zavrsi sa radom dropuje ih (create-drop)
#https://www.baeldung.com/spring-boot-data-sql-and-schema-sql
#Ako ?elimo sami da kreiramo skriptu za kreiranje tabela potrebno je u src/main/resources folderu kreirati i popuniti fajl pod nazivom schema.sql koji ?e Spring Boot automatski pokrenuti pri pokretanju aplikacije
#spring.jpa.hibernate.ddl-auto = create-drop
spring.jpa.defer-datasource-initialization=true

#Hibernate SQL upiti se ispisuju na IDE konzoli
#spring.jpa.show-sql = true

#formatira ispis SQL upita koje Hibernate pravi ka bazi na IDE konzoli
spring.jpa.properties.hibernate.format_sql=true

spring.jpa.database-platform=org.hibernate.dialect.PostgreSQL81Dialect

#https://stackoverflow.com/questions/43905119/postgres-error-method-org-postgresql-jdbc-pgconnection-createclob-is-not-imple
spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true

#https://vladmihalcea.com/the-open-session-in-view-anti-pattern/
spring.jpa.open-in-view=false

spring.sql.init.mode=always
spring.batch.jdbc.initialize-schema=always

#spring.h2.console.enabled=true

spring.security.user.name=test
spring.security.user.password=test
jwt.secret=korisnickoime
token.expiration= 30000
jwt.refreshExpiration = 48000


#server.ssl.key-store= keystore.p12
#server.ssl.key-store-password= springboot
#server.ssl.keyStoreType= PKCS12
#server.ssl.keyAlias= tomcat
#server.ssl.enabled=true

#logging.level.root=INFO
#logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n

SENDGRID_API_KEY=
SENDER_EMAIL=
TWILIO_AUTH_TOKEN=
TWILIO_ACCOUNT_SID=

# OAuth 2.0 Client Configuration
spring.security.oauth2.client.registration.google.client-id=167528322201-u8taq6t9c4kjmcnf1ga9bj214i3j7ov6.apps.googleusercontent.com
spring.security.oauth2.client.registration.google.client-secret=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
#spring.security.oauth2.client.registration.google.redirect-uri=http://localhost:8080/login/oauth2/code/google
spring.security.oauth2.client.registration.google.scope=openid,email,profile
#spring.security.oauth2.client.provider.google.authorization-uri=https://accounts.google.com/o/oauth2/auth
#spring.security.oauth2.client.provider.google.token-uri=https://accounts.google.com/o/oauth2/token
#spring.security.oauth2.client.provider.google.user-info-uri=https://www.googleapis.com/oauth2/v3/userinfo
# spring.security.oauth2.client.provider.google.user-name-attribute=email

